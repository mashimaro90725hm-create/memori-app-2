<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å¿†æ – Â· Memori</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+JP:wght@400;700&family=Noto+Serif+KR:wght@400;700&family=Noto+Serif+SC:wght@400;700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Zen+Old+Mincho:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

    <style>
        :root {
            --color-bg-main: #E2E1E4;
            --color-text-main: #2D241E; 
            --color-accent: #CB3A56;
            --color-accent-hover: #EF7A82; 
            --glass-bg: rgba(255, 253, 248, 0.85);
            --glass-border: rgba(203, 58, 86, 0.15); 
        }

        /* --- åŸºç¡€å¸ƒå±€ --- */
        * { box-sizing: border-box; user-select: none; }
        body { margin: 0; overflow: hidden; background: #f0f0f0; }
        
        .app-container { display: flex; width: 100vw; height: 100vh; overflow: hidden; transition: background 0.5s ease, font-family 0.3s; position: relative; color: var(--color-text-main); }
        
        /* çº¹ç†èƒŒæ™¯ (Multiply æ··åˆ) */
        .app-container::before { 
            content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.04'/%3E%3C/svg%3E"); 
            pointer-events: none; z-index: 0; mix-blend-mode: multiply; 
        }

        /* æ¯›ç»ç’ƒç»„ä»¶ */
        .glass-morphism { 
            background: var(--glass-bg); backdrop-filter: blur(20px) saturate(110%); 
            border: 1px solid var(--glass-border);
            box-shadow: 0 4px 12px -1px rgba(45, 36, 30, 0.08);
            border-radius: 24px; 
        }

        /* --- ä¾§è¾¹æ  (Sidebar) --- */
        .sidebar { width: 280px; display: flex; flex-direction: column; padding: 30px 20px; z-index: 20; margin: 20px 0 20px 20px; }
        .sidebar-header { padding-bottom: 16px; border-bottom: 1px solid var(--glass-border); display: flex; justify-content: space-between; align-items: center; }
        .sidebar-header h3 { margin: 0; font-size: 1.1rem; font-weight: bold; }
        .import-btn { background: none; border: none; cursor: pointer; color: var(--color-accent); font-size: 0.9rem; transition: opacity 0.2s; }
        .import-btn:hover { opacity: 0.7; }

        .word-list { flex: 1; overflow-y: auto; padding: 15px 0; }
        .word-list::-webkit-scrollbar { width: 4px; }
        .word-list::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.1); border-radius: 2px; }

        .word-item { padding: 12px 16px; margin-bottom: 8px; border-radius: 12px; cursor: pointer; transition: all 0.2s; background: rgba(255,255,255,0.4); border-left: 3px solid transparent; display: flex; justify-content: space-between; align-items: center; }
        .word-item:hover { background: rgba(255,255,255,0.8); transform: translateX(2px); }
        .word-item.active { background: white; border-left-color: var(--color-accent); font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
        .local-icon { font-size: 0.7rem; color: #8d6e63; margin-left: 5px; opacity: 0.7; }

        .sidebar-footer { padding-top: 20px; display: flex; flex-direction: column; gap: 10px; border-top: 1px solid var(--glass-border); }
        .action-btn { width: 100%; padding: 12px; border-radius: 16px; border: none; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.2s; }
        .action-btn.primary { color: white; background: var(--color-accent); }
        .action-btn.primary:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(203, 58, 86, 0.3); }
        .action-btn.outline { background: rgba(255,255,255,0.6); border: 1px solid var(--glass-border); }
        .action-btn.outline:hover { background: white; transform: translateY(-2px); }

        /* --- ä¸»èˆå° (Main Stage) --- */
        .main-stage { flex: 1; position: relative; display: flex; flex-direction: column; padding: 20px; z-index: 10; }

        /* æœç´¢æ  */
        .search-bar { margin: 0 20px 20px; padding: 10px 20px; display: flex; align-items: center; z-index: 50; }
        .lang-scroll { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 4px; max-width: 40%; margin-right: 15px; }
        .lang-scroll::-webkit-scrollbar { height: 0px; }
        .lang-pill { padding: 6px 12px; border-radius: 8px; border: 1px solid transparent; background: rgba(255,255,255,0.5); cursor: pointer; font-size: 0.85rem; white-space: nowrap; transition: all 0.2s; }
        .lang-pill.active { background: white; border-color: var(--color-accent); color: var(--color-accent); font-weight: bold; transform: scale(1.05); }
        
        .search-input { flex: 1; border: none; background: transparent; font-size: 1.1rem; outline: none; font-family: inherit; color: var(--color-text-main); }
        .search-btn { background: none; border: none; font-size: 1.2rem; cursor: pointer; color: var(--color-accent); }

        /* å¡ç‰‡å®¹å™¨ */
        .content-area { flex: 1; display: flex; justify-content: center; align-items: center; position: relative; }
        
        /* 3D ç¿»è½¬å¡ç‰‡ (çº¯æ–‡å­—ç‰ˆ) */
        .card-3d-wrapper { width: 420px; height: 620px; perspective: 1500px; cursor: pointer; }
        .card-body { width: 100%; height: 100%; position: relative; transition: transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1); transform-style: preserve-3d; }
        .card-body.is-flipped { transform: rotateY(180deg); }
        .card-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; border-radius: 24px; overflow: hidden; background: #fffdf9; display: flex; flex-direction: column; }
        
        /* æ­£é¢è®¾è®¡ */
        .front-content { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 40px; text-align: center; position: relative; }
        .front-bg-pattern { position: absolute; top:0; left:0; width:100%; height:100%; opacity: 0.05; background-image: radial-gradient(var(--color-text-main) 1px, transparent 1px); background-size: 20px 20px; z-index: 0; pointer-events: none; }
        .word-main { font-size: 3.5rem; font-family: 'Zen Old Mincho', serif; margin: 20px 0; z-index: 2; position: relative; }
        .word-pinyin { font-size: 1rem; color: var(--color-accent); font-family: sans-serif; margin-bottom: -15px; z-index: 2; opacity: 0.8; }
        .word-reading { font-size: 1.2rem; opacity: 0.6; margin-bottom: 20px; font-family: serif; z-index: 2; display: flex; align-items: center; gap: 10px; }
        .word-meaning { font-size: 1.1rem; line-height: 1.6; max-width: 90%; z-index: 2; border-top: 1px solid rgba(0,0,0,0.1); padding-top: 20px; }
        .local-badge { position: absolute; top: 20px; right: 20px; font-size: 1.5rem; color: #8d6e63; opacity: 0.8; }
        
        /* èƒŒé¢è®¾è®¡ */
        .card-face.back { transform: rotateY(180deg); background: #fffcf5; }
        .back-scroll { padding: 30px; overflow-y: auto; height: 100%; }
        .section-title { font-size: 0.85rem; color: var(--color-accent); letter-spacing: 1px; margin: 20px 0 10px; border-bottom: 1px dashed rgba(0,0,0,0.1); padding-bottom: 5px; font-weight: bold; }
        .detail-text { font-size: 1rem; line-height: 1.8; text-align: justify; margin-bottom: 10px; }
        .example-item { background: rgba(0,0,0,0.03); padding: 10px; border-radius: 8px; margin-bottom: 10px; border-left: 3px solid var(--color-accent); }
        .ex-origin { font-family: serif; font-size: 1.05rem; margin-bottom: 4px; }
        .ex-trans { font-size: 0.9rem; opacity: 0.7; }
        
        /* --- æ•°å­—èŠ±ç”° (Garden) --- */
        .gallery-mode { width: 100%; height: 100%; padding: 20px; overflow-y: auto; }
        .garden-canvas { 
            position: relative; width: 100%; min-height: 500px; 
            background: linear-gradient(to top, rgba(255,255,255,0.4), rgba(255,255,255,0));
            border-radius: 24px; border: 1px solid var(--glass-border);
            overflow: hidden; perspective: 1000px;
        }
        .plant-img { 
            position: absolute; bottom: 0; 
            /* å»ç™½åº•æ ¸å¿ƒ + éšæœºäº¤é”™ */
            mix-blend-mode: multiply; 
            transition: transform 0.3s;
            filter: contrast(1.1) saturate(1.1);
        }
        .plant-img:hover { transform: scale(1.1) !important; z-index: 1000 !important; cursor: pointer; }

        /* --- ç•ªèŒ„é’Ÿ (Pomodoro) --- */
        .pomodoro-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #2D241E; z-index: 2000; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #F3F2F0; }
        .timer-display { font-size: 6rem; font-family: 'Cinzel', serif; font-weight: bold; margin: 30px 0; letter-spacing: 5px; text-shadow: 0 0 20px rgba(255,255,255,0.1); }
        .pomodoro-icon { width: 180px; height: 180px; object-fit: contain; animation: breathe 4s infinite ease-in-out; }
        .shiba-sleep { width: 200px; height: auto; margin-top: 30px; opacity: 0.8; }
        .focus-btn { background: transparent; border: 1px solid rgba(255,255,255,0.3); color: white; padding: 10px 30px; border-radius: 30px; cursor: pointer; transition: all 0.3s; margin-top: 20px; }
        .focus-btn:hover { background: rgba(255,255,255,0.1); border-color: white; }

        /* --- çœ‹æ¿å¨˜ & äº¤äº’ --- */
        .cat-container { 
            position: fixed; bottom: 20px; right: 20px; 
            width: 280px; /* å›ºå®šå®½åº¦ */
            height: 280px; z-index: 100; pointer-events: none; 
        }
        .cat-img { width: 100%; height: 100%; object-fit: contain; transform: scaleX(-1); filter: drop-shadow(0 10px 20px rgba(0,0,0,0.2)); }
        
        .mascot-bubble {
            position: absolute; top: 0; left: 50%; transform: translateX(-50%);
            background: white; padding: 8px 16px; border-radius: 12px;
            font-size: 0.9rem; font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            white-space: nowrap; animation: popIn 0.3s;
        }

        /* æ¨¡æ€æ¡† */
        .modal-mask { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.4); z-index: 3000; display: flex; justify-content: center; align-items: center; backdrop-filter: blur(5px); }
        .modal-box { background: white; padding: 30px; border-radius: 24px; width: 400px; max-width: 90%; box-shadow: 0 20px 50px rgba(0,0,0,0.2); }
        .modal-title { font-size: 1.4rem; margin-bottom: 20px; font-weight: bold; color: var(--color-text-main); }

        @keyframes breathe { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        @keyframes popIn { from { opacity: 0; transform: translate(-50%, 10px); } to { opacity: 1; transform: translate(-50%, 0); } }
    </style>
</head>
<body>
    <div id="app">
        <Transition name="fade">
            <div v-if="mode === 'focus'" class="pomodoro-overlay">
                <img src="./pomodoro-timer.png" class="pomodoro-icon" alt="Timer">
                <div class="timer-display">{{ formatTime(timeLeft) }}</div>
                <div style="opacity: 0.6; letter-spacing: 2px;">{{ focusDuration >= 60 ? 'ğŸŒŠ æ·±æ½œæ¨¡å¼ Â· å¿…å¾—ç‰¹ç­‰æ¤è¢«' : 'ğŸŒ¿ ä¸“æ³¨æ¨¡å¼ Â· åŸ¹è‚²è®°å¿†' }}</div>
                <img src="./shiba-sleep.gif" class="shiba-sleep" alt="Sleeping Shiba">
                <button class="focus-btn" @click="abortFocus">ä¸­æ­¢ä¸“æ³¨</button>
            </div>
        </Transition>

        <div class="app-container" :style="{ background: langConfig[currentLang].bg }">
            
            <aside class="sidebar glass-morphism">
                <div class="sidebar-header">
                    <h3>ğŸ“š {{ langConfig[currentLang].name }} <span style="font-size:0.8em; opacity:0.5">({{ filteredHistory.length }})</span></h3>
                    <button class="import-btn" @click="showImportModal = true" title="æŒ‚è½½æœ¬åœ°è¾å…¸"><i class="fa-solid fa-file-import"></i></button>
                </div>
                
                <div class="word-list">
                    <div v-for="item in filteredHistory" :key="item.id" 
                         class="word-item" :class="{ active: currentWord && currentWord.id === item.id }"
                         @click="loadWord(item)">
                        <span>{{ item.word }}</span>
                        <i v-if="item.isLocal" class="fa-solid fa-scroll local-icon" title="æ¥è‡ªæœ¬åœ°å¤ç±"></i>
                    </div>
                </div>

                <div class="sidebar-footer">
                    <button class="action-btn primary" @click="startFocusSelect"><i class="fa-solid fa-hourglass-half"></i> ç„šé¦™ Â· æ·±æ½œ</button>
                    <button class="action-btn outline" @click="mode = 'garden'"><i class="fa-solid fa-seedling"></i> è®°å¿†èŠ±ç”°</button>
                    <button class="action-btn outline" @click="exportData"><i class="fa-solid fa-download"></i> å¤‡ä»½è®°å¿†</button>
                </div>
            </aside>

            <main class="main-stage">
                <div class="search-bar glass-morphism">
                    <div class="lang-scroll">
                        <div v-for="(cfg, key) in langConfig" :key="key" 
                             class="lang-pill" :class="{ active: currentLang === key }"
                             @click="currentLang = key">
                             {{ cfg.flag }} {{ cfg.name }}
                        </div>
                    </div>
                    <input v-model="wordInput" @keyup.enter="handleSearch" class="search-input" :placeholder="`åœ¨${langConfig[currentLang].name}ä¸­å¯»è§…...`">
                    <button @click="handleSearch" class="search-btn"><i class="fa-solid fa-magnifying-glass"></i></button>
                </div>

                <div class="content-area">
                    
                    <div v-if="mode === 'garden'" class="gallery-mode custom-scroll">
                        <div style="margin-bottom: 15px; display: flex; justify-content: space-between;">
                            <h2 style="margin:0; font-family: 'Zen Old Mincho'">è®°å¿†èŠ±ç”°</h2>
                            <button @click="isEditMode = !isEditMode" class="import-btn">{{ isEditMode ? 'é”å®šå¸ƒå±€' : 'ä¿®å‰ªæå¶' }}</button>
                        </div>
                        <div class="garden-canvas" :style="{ height: gardenHeight + 'px' }">
                            <img v-for="plant in gardenPlants" :key="plant.id"
                                 :src="plant.src"
                                 class="plant-img"
                                 :style="{ 
                                     left: plant.x + '%', 
                                     bottom: plant.y + '%', 
                                     width: plant.size + 'px', 
                                     zIndex: plant.zIndex 
                                 }"
                                 @mousedown="startDrag($event, plant)"
                            >
                        </div>
                    </div>

                    <div v-else class="card-3d-wrapper" @click="toggleFlip">
                        <div class="card-body glass-morphism" :class="{ 'is-flipped': isFlipped }">
                            
                            <div class="card-face front">
                                <div class="front-bg-pattern"></div>
                                <i v-if="currentWord && currentWord.isLocal" class="fa-solid fa-scroll local-badge"></i>
                                
                                <div v-if="loading" style="opacity: 0.5"><i class="fa-solid fa-circle-notch fa-spin fa-2x"></i></div>
                                
                                <div v-else-if="currentWord">
                                    <div v-if="currentWord.pinyin" class="word-pinyin">{{ currentWord.pinyin }}</div>
                                    <div class="word-main">{{ currentWord.word }}</div>
                                    <div class="word-reading">
                                        {{ currentWord.reading }}
                                        <i v-if="canSpeak" @click.stop="speak(currentWord.word)" class="fa-solid fa-volume-high" style="cursor:pointer; margin-left:8px; font-size:0.9em"></i>
                                    </div>
                                    <div class="word-meaning">{{ currentWord.meaning }}</div>
                                </div>
                                <div v-else style="opacity: 0.4">è¾“å…¥è¯æ±‡ï¼Œå¼€å¯æ¢ç´¢</div>
                            </div>

                            <div class="card-face back">
                                <div class="back-scroll custom-scroll" v-if="currentWord">
                                    <div class="section-title">ğŸ—ï¸ è¯æºè€ƒæ® (Etymology)</div>
                                    <div class="detail-text">{{ currentWord.etymology || 'æ­£åœ¨è€ƒæ®ä¸­...' }}</div>
                                    
                                    <div class="section-title">ğŸ“œ å…¸ç±ä¾‹å¥ (Sentences)</div>
                                    <div v-if="currentWord.examples && currentWord.examples.length">
                                        <div v-for="(ex, i) in currentWord.examples" :key="i" class="example-item">
                                            <div class="ex-origin" @click.stop="speak(ex.text)">
                                                {{ ex.text }} <i v-if="canSpeak" class="fa-solid fa-volume-low" style="font-size:0.8em; opacity:0.5"></i>
                                            </div>
                                            <div class="ex-trans">{{ ex.cn }}</div>
                                        </div>
                                    </div>
                                    <div v-else class="detail-text" style="opacity:0.5">æš‚æ— æ”¶å½•ä¾‹å¥</div>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
            </main>

            <div class="cat-container">
                <img src="./my-cat.png" class="cat-img" alt="Mascot">
                <div v-if="mascotMsg" class="mascot-bubble">{{ mascotMsg }}</div>
            </div>
        </div>

        <div v-if="showImportModal" class="modal-mask" @click.self="showImportModal = false">
            <div class="modal-box">
                <div class="modal-title">æŒ‚è½½ç¦»çº¿è¾å…¸</div>
                <div style="margin-bottom: 15px;">
                    <label style="display:block; margin-bottom:5px; font-weight:bold;">1. é€‰æ‹©è¯­ç§å½’å±</label>
                    <select v-model="importLang" style="width:100%; padding:10px; border-radius:8px; border:1px solid #ccc;">
                        <option v-for="(cfg, key) in langConfig" :key="key" :value="key">{{ cfg.flag }} {{ cfg.name }} ({{ key.toUpperCase() }})</option>
                    </select>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display:block; margin-bottom:5px; font-weight:bold;">2. ä¸Šä¼  JSON æ–‡ä»¶</label>
                    <input type="file" ref="fileInput" accept=".json" style="width:100%">
                </div>
                <div style="display: flex; gap: 10px;">
                    <button @click="importDictionary" class="action-btn primary" :disabled="isImporting">{{ isImporting ? 'å¯¼å…¥ä¸­...' : 'ç¡®è®¤æŒ‚è½½' }}</button>
                    <button @click="showImportModal = false" class="action-btn outline">å–æ¶ˆ</button>
                </div>
            </div>
        </div>

        <div v-if="showFocusSelect" class="modal-mask" @click.self="showFocusSelect = false">
            <div class="modal-box" style="text-align:center;">
                <div class="modal-title">é€‰æ‹©æ·±æ½œæ—¶é•¿</div>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:20px;">
                    <button v-for="min in [15, 30, 45, 60, 120]" :key="min" 
                            class="action-btn outline" 
                            @click="startPomodoro(min)">
                        {{ min }} åˆ†é’Ÿ {{ min >= 60 ? 'ğŸŒŠ' : '' }}
                    </button>
                </div>
                <p style="font-size:0.8rem; opacity:0.6;">60åˆ†é’Ÿä»¥ä¸Šå¿…å¾—ã€ç‰¹ç­‰æ¤è¢«ã€‘</p>
            </div>
        </div>

    </div>

    <script>
        const { createApp, ref, computed, onMounted, reactive, watch } = Vue;

        // --- IndexedDB å¸®åŠ©ç±» (æœ¬åœ°è¾å…¸æ ¸å¿ƒ) ---
        class DictionaryDB {
            constructor() {
                this.dbName = 'MemoriDictDB_V2';
                this.db = null;
            }
            async open() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, 1);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('dictionaries')) {
                            // å¤åˆç´¢å¼•ï¼šè¯­ç§ + å•è¯
                            const store = db.createObjectStore('dictionaries', { keyPath: 'id', autoIncrement: true });
                            store.createIndex('lang_word', ['lang', 'wordName'], { unique: false });
                        }
                    };
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        resolve(this.db);
                    };
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            async addBulk(lang, items) {
                if (!this.db) await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['dictionaries'], 'readwrite');
                    const store = transaction.objectStore('dictionaries');
                    let count = 0;
                    items.forEach(item => {
                        // ç¡®ä¿æ•°æ®ç»“æ„ standardized
                        store.add({
                            lang: lang,
                            wordName: item.wordName || item.word,
                            wordDesc: item.wordDesc || item.meaning,
                            pronunciation: item.pronunciation || item.reading || '',
                            raw: item // ä¿ç•™åŸå§‹æ•°æ®
                        });
                        count++;
                    });
                    transaction.oncomplete = () => resolve(count);
                    transaction.onerror = () => reject(transaction.error);
                });
            }
            async find(lang, word) {
                if (!this.db) await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['dictionaries'], 'readonly');
                    const store = transaction.objectStore('dictionaries');
                    const index = store.index('lang_word');
                    const request = index.get([lang, word]);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }
        }

        createApp({
            setup() {
                // --- çŠ¶æ€å®šä¹‰ ---
                const dictDB = new DictionaryDB();
                const mode = ref('card'); // card, garden, focus
                const currentLang = ref('jp');
                const wordInput = ref('');
                const loading = ref(false);
                const isFlipped = ref(false);
                const currentWord = ref(null);
                const history = ref(JSON.parse(localStorage.getItem('memori_history_v2') || '[]'));
                const gardenPlants = ref(JSON.parse(localStorage.getItem('memori_garden_v2') || '[]'));
                
                // æ¨¡æ€æ¡†æ§åˆ¶
                const showImportModal = ref(false);
                const importLang = ref('cjp');
                const isImporting = ref(false);
                const fileInput = ref(null);
                
                // çœ‹æ¿å¨˜
                const mascotMsg = ref('');
                
                // ç•ªèŒ„é’Ÿ
                const showFocusSelect = ref(false);
                const timeLeft = ref(0);
                const focusDuration = ref(0);
                let timerInterval = null;

                // è¯­ç§é…ç½® (9ç§)
                const langConfig = {
                    jp: { name: 'æ—¥è¯­', flag: 'ğŸ‡¯ğŸ‡µ', bg: '#F9F1F0', code: 'ja-JP' },
                    cjp: { name: 'å¤æ—¥è¯­', flag: 'ğŸ¯', bg: '#EBE6DF', code: 'ja-JP' }, // Use JP voice
                    zh: { name: 'ç°ä»£æ±‰è¯­', flag: 'ğŸ‡¨ğŸ‡³', bg: '#FBF8F1', code: 'zh-CN' },
                    lzh: { name: 'å¤æ±‰è¯­', flag: 'ğŸ“œ', bg: '#E9EAE4', code: 'zh-CN' },
                    en: { name: 'è‹±è¯­', flag: 'ğŸ‡¬ğŸ‡§', bg: '#E6E8EB', code: 'en-US' },
                    de: { name: 'å¾·è¯­', flag: 'ğŸ‡©ğŸ‡ª', bg: '#E8ECEB', code: 'de-DE' },
                    it: { name: 'æ„è¯­', flag: 'ğŸ‡®ğŸ‡¹', bg: '#F8F4E8', code: 'it-IT' },
                    lat: { name: 'æ‹‰ä¸è¯­', flag: 'ğŸ›ï¸', bg: '#EAE8E6', code: 'it-IT' }, // Fallback to Italian/Church Latinish
                    kr: { name: 'éŸ©è¯­', flag: 'ğŸ‡°ğŸ‡·', bg: '#F7EFF2', code: 'ko-KR' }
                };

                const filteredHistory = computed(() => history.value.filter(h => h.lang === currentLang.value).reverse());
                const canSpeak = computed(() => !['zh', 'lzh'].includes(currentLang.value)); // ä¸­æ–‡ä¸å‘éŸ³

                onMounted(async () => {
                    await dictDB.open();
                });

                // --- æ ¸å¿ƒé€»è¾‘ 1: è¾å…¸æ£€ç´¢ (Double Track) ---
                async function handleSearch() {
                    if (!wordInput.value.trim()) return;
                    loading.value = true;
                    mode.value = 'card';
                    isFlipped.value = false;
                    const query = wordInput.value.trim();
                    const lang = currentLang.value;

                    try {
                        // Track 1: æœ¬åœ°æ£€ç´¢
                        const localRes = await dictDB.find(lang, query);
                        
                        let baseData = null;

                        if (localRes) {
                            // æœ¬åœ°å‘½ä¸­
                            baseData = {
                                id: Date.now(),
                                word: localRes.wordName,
                                reading: localRes.pronunciation,
                                meaning: localRes.wordDesc,
                                isLocal: true,
                                lang: lang,
                                etymology: 'æ­£åœ¨æŸ¥é˜…äº‘ç«¯è€ƒæ®...',
                                examples: []
                            };
                            currentWord.value = baseData;
                            addToHistory(baseData);
                            loading.value = false; // UI ç«‹å³å“åº”

                            // é™é»˜è§¦å‘ API è¡¥å…¨
                            fetchEnrichment(query, lang, baseData.id);
                        } else {
                            // Track 2: å…¨é‡ API æ£€ç´¢
                            const res = await fetch('/api/openai', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ word: query, lang: lang })
                            });
                            const apiData = await res.json();
                            baseData = { ...apiData, id: Date.now(), lang: lang, isLocal: false };
                            currentWord.value = baseData;
                            addToHistory(baseData);
                            loading.value = false;
                        }

                        // å¥–åŠ±åˆ¤å®š (æ¯10è¯)
                        if (history.value.length % 10 === 0) {
                            addPlantToGarden(false); // å¸¸è§„å¥–åŠ±
                            showMascotMsg('ğŸŒ± èŠ±ç”°é‡Œé•¿å‡ºäº†ä¸€æ ªæ–°èŠ½ï¼');
                        }

                    } catch (e) {
                        alert('æ£€ç´¢å‡ºé”™: ' + e.message);
                        loading.value = false;
                    }
                }

                async function fetchEnrichment(word, lang, tempId) {
                    try {
                        const res = await fetch('/api/openai', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ word, lang, type: 'enrichment' })
                        });
                        const data = await res.json();
                        // æ›´æ–°å½“å‰æ˜¾ç¤ºçš„å¡ç‰‡
                        if (currentWord.value && currentWord.value.id === tempId) {
                            currentWord.value.etymology = data.etymology;
                            currentWord.value.examples = data.examples;
                            currentWord.value.pinyin = data.pinyin; // å¦‚æœæœ‰
                        }
                        // æ›´æ–°å†å²è®°å½•
                        const histIdx = history.value.findIndex(h => h.id === tempId);
                        if (histIdx !== -1) {
                            history.value[histIdx] = { ...history.value[histIdx], ...data };
                            saveHistory();
                        }
                    } catch (e) { console.error('Enrichment failed', e); }
                }

                function addToHistory(item) {
                    // å»é‡
                    const idx = history.value.findIndex(h => h.word === item.word && h.lang === item.lang);
                    if (idx !== -1) history.value.splice(idx, 1);
                    history.value.push(item);
                    saveHistory();
                }

                function loadWord(item) {
                    currentWord.value = item;
                    mode.value = 'card';
                    isFlipped.value = false;
                }

                // --- æ ¸å¿ƒé€»è¾‘ 2: è¾å…¸å¯¼å…¥ ---
                async function importDictionary() {
                    const file = fileInput.value.files[0];
                    if (!file) return alert('è¯·é€‰æ‹© JSON æ–‡ä»¶');
                    isImporting.value = true;
                    
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const json = JSON.parse(e.target.result);
                            // å…¼å®¹ data å­—æ®µæˆ–ç›´æ¥æ•°ç»„
                            const items = Array.isArray(json) ? json : (json.data || []);
                            const count = await dictDB.addBulk(importLang.value, items);
                            alert(`æˆåŠŸæŒ‚è½½ ${count} æ¡è¯ç›®åˆ°ã€${langConfig[importLang.value].name}ã€‘åº“`);
                            showImportModal.value = false;
                        } catch (err) {
                            alert('å¯¼å…¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ JSON æ ¼å¼');
                        } finally {
                            isImporting.value = false;
                        }
                    };
                    reader.readAsText(file);
                }

                // --- æ ¸å¿ƒé€»è¾‘ 3: èŠ±ç”°ä¸æ¤ç‰© (ä¸€æ ‘å››å˜) ---
                function addPlantToGarden(isSpecial) {
                    // 1. å†³å®šæ¤ç‰© ID
                    let plantType;
                    if (isSpecial) {
                        const specials = ['spec_ginkgo', 'spec_wisteria'];
                        plantType = specials[Math.floor(Math.random() * specials.length)];
                    } else {
                        // å¸¸è§„ 20 ç§
                        const commons = ['fruit_cherry', 'flow_sakura', 'fruit_grape', 'flow_peony', 'rare_mushroom']; // ç¤ºä¾‹ç¼©å‡ï¼Œå®é™…è¯·å¡«å…¥æ‰€æœ‰20ç§
                        plantType = commons[Math.floor(Math.random() * commons.length)];
                    }
                    
                    // 2. éšæœºå˜ä½“ (1-4)
                    const variant = Math.floor(Math.random() * 4) + 1;
                    const fileName = `${plantType}_${variant}.png`;

                    // 3. éšæœºä½ç½® (CSS å»ç™½ + å±‚å )
                    const newPlant = {
                        id: Date.now(),
                        src: `./assets/plants/${fileName}`,
                        x: Math.random() * 80 + 5, // 5% - 85%
                        y: Math.random() * 30,     // åº•éƒ¨å †å 
                        size: Math.random() * 80 + 100, // 100-180px
                        zIndex: gardenPlants.value.length + 1
                    };
                    gardenPlants.value.push(newPlant);
                    localStorage.setItem('memori_garden_v2', JSON.stringify(gardenPlants.value));
                }

                // --- æ ¸å¿ƒé€»è¾‘ 4: ç•ªèŒ„é’Ÿ ---
                function startFocusSelect() { showFocusSelect.value = true; }
                function startPomodoro(minutes) {
                    showFocusSelect.value = false;
                    focusDuration.value = minutes;
                    timeLeft.value = minutes * 60;
                    mode.value = 'focus';
                    
                    if (timerInterval) clearInterval(timerInterval);
                    timerInterval = setInterval(() => {
                        timeLeft.value--;
                        if (timeLeft.value <= 0) {
                            finishPomodoro();
                        }
                    }, 1000);
                }
                function finishPomodoro() {
                    clearInterval(timerInterval);
                    mode.value = 'card'; // é€€å‡ºä¸“æ³¨
                    alert('â° ä¸“æ³¨å®Œæˆï¼');
                    
                    // å¥–åŠ±åˆ¤å®š
                    const isSpecial = focusDuration.value >= 60;
                    addPlantToGarden(isSpecial);
                    showMascotMsg(isSpecial ? 'ğŸŒŠ æ·±æ½œå½’æ¥ï¼Œè·å¾—ã€ç‰¹ç­‰æ¤è¢«ã€‘ï¼' : 'ğŸŒ¿ è·å¾—äº†ä¸€æ ªæ–°æ¤ç‰©ï¼');
                }
                function abortFocus() {
                    if (confirm('ç¡®å®šè¦æ”¾å¼ƒæœ¬æ¬¡ä¸“æ³¨å—ï¼Ÿå°†ä¸ä¼šè·å¾—å¥–åŠ±ã€‚')) {
                        clearInterval(timerInterval);
                        mode.value = 'card';
                    }
                }
                function formatTime(seconds) {
                    const m = Math.floor(seconds / 60).toString().padStart(2, '0');
                    const s = (seconds % 60).toString().padStart(2, '0');
                    return `${m}:${s}`;
                }

                // --- è¾…åŠ©åŠŸèƒ½ ---
                function speak(text) {
                    if (!canSpeak.value) return;
                    window.speechSynthesis.cancel();
                    const u = new SpeechSynthesisUtterance(text);
                    u.lang = langConfig[currentLang.value].code;
                    window.speechSynthesis.speak(u);
                }
                function saveHistory() { localStorage.setItem('memori_history_v2', JSON.stringify(history.value)); }
                function exportData() {
                    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify({ history: history.value, garden: gardenPlants.value }));
                    const downloadAnchorNode = document.createElement('a');
                    downloadAnchorNode.setAttribute("href", dataStr);
                    downloadAnchorNode.setAttribute("download", "memori_backup.json");
                    document.body.appendChild(downloadAnchorNode);
                    downloadAnchorNode.click();
                    downloadAnchorNode.remove();
                }
                function showMascotMsg(msg) {
                    mascotMsg.value = msg;
                    setTimeout(() => mascotMsg.value = '', 4000);
                }
                function toggleFlip() { isFlipped.value = !isFlipped.value; }

                // æ‹–æ‹½é€»è¾‘ (ç®€å•å®ç°)
                const isEditMode = ref(false);
                function startDrag(e, plant) {
                    if (!isEditMode.value) return;
                    // ... æ‹–æ‹½é€»è¾‘çœç•¥ï¼Œä»…éœ€å®ç°æ›´æ–° plant.x/y å³å¯ ...
                }

                return {
                    mode, currentLang, wordInput, loading, isFlipped, currentWord, history, filteredHistory,
                    langConfig, handleSearch, loadWord, speak, canSpeak,
                    showImportModal, importLang, fileInput, isImporting, importDictionary,
                    showFocusSelect, startFocusSelect, startPomodoro, abortFocus, timeLeft, focusDuration, formatTime,
                    gardenPlants, isEditMode, startDrag, toggleFlip,
                    mascotMsg, exportData
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
